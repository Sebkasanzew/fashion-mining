#!/usr/bin/env python
# -*- coding: utf-8 -*-

import decimal
import json
from pprint import pprint

import lxml  # xml functions
from lxml.html import builder as E  # for building a html document


def uni2utf(string=str()):
    """
    Converts an unicode string into an utf-8 string.
    :param string: the unicode string
    :type string: str
    :return: An UTF-8 string
    :rtype: str
    """
    return unicode(string).encode('utf8')


def sort_2d_array(array=None):
    """
    Sort a 2D array after the first number ascending.
    :param array: unsorted 2D-list
    :type array: list
    :return: sorted 2D-list
    :rtype: list[list[int]]
    """
    if array is None:
        return []
    return sorted(array, key=lambda l: l[0], reverse=False)


def merge_intersected_indices(array_one=None, array_two=None):
    """
    Merges two list elements into one list if they ave an intersection.
    :param array_one: first list element
    :param array_two: second list element
    :type array_one: list[int]
    :type array_two: list[int]
    :return: returns the intersected list.
    :rtype: list[int]
    """
    if array_one is None:
        array_one = []

    if array_two is None:
        array_two = []

    if array_one[1] >= array_two[0]:
        return [array_one[0], array_two[1]]
    elif (array_two[1] >= array_one[0]) and (array_two[0] < array_one[0]):  # if the given parameters are switched
        return [array_two[0], array_one[1]]
    else:
        return False


def compare_docs(gold_document=None, w2v_document=None, mode=None, steps=0.05):
    # STEP 1
    """
    Compares two documents/sentences.
    :param gold_document: the document with the gold standard
    :param w2v_document: the document generated by word2vec
    :param mode: the data calculation mode
    :param steps: the precision of the graph
    :type gold_document: list
    :type w2v_document: list
    :type mode: str
    :type steps: float
    :return: A 2D-list with the graph data. The values should be between 0 and 1.
    :rtype: list[list[int]]
    """
    if (gold_document is None) or (gold_document is False):
        gold_document = [{"entities": ["a", "b"],
                          "_id": "b1",
                          "indices": [
                              [[1, 2], [4, 6]],
                              [[8, 10]],
                              [[22, 32]]
                          ]}]

    if (w2v_document is None) or (w2v_document is False):
        w2v_document = [{"entities": ["a", "b", "c", "d"],
                         "_id": "b1",
                         "cos_dist": [["wort", .7], ["wort", .9], ["wort", .2], ["wort", .4]],
                         "indices": [
                             [[14, 18]],
                             [[1, 2], [4, 6]],
                             [[8, 10]],
                             [[11, 13], [14, 16]]
                         ]}]

    # add the cos_dist to the indices array
    for w2v_doc in w2v_document:
        for i, val in enumerate(w2v_doc["indices"]):
            cos = uni2utf(w2v_doc["cos_dist"][i][1])
            if cos == "None":  # TODO needs some more thinking
                cos = 0
            cos = float(cos)
            for j in w2v_doc["indices"][i]:
                j.append(cos)

    compared = []

    for gold_doc in gold_document:
        for w2v_doc in w2v_document:
            if gold_doc["_id"] == w2v_doc["_id"]:  # check if the sentences are identical
                append = compare_indices(gold_doc["indices"], w2v_doc["indices"])
                compared.append(append)
                # print "compared:"
                # print pprint(compared)

    graph_data = []

    if mode == "precision":
        for i in step_range(0, 1, steps):
            pr = calc_cos_precision(i, compared)
            graph_data.append(pr)
    elif mode == "recall":
        for i in step_range(0, 1, steps):
            pr = calc_cos_recall(i, compared)
            graph_data.append(pr)
    elif mode == "f1":
        for i in step_range(0, 1, steps):
            f1 = calc_f1_score(i, compared)
            graph_data.append(f1)
    else:
        for i in step_range(0, 1, steps):
            pr = calc_precision_recall(i, compared)
            graph_data.append(pr)

    graph_data = sorted(graph_data)

    pprint(graph_data)

    return graph_data


def compare_indices(gold_indices, w2v_indices):
    """
    :param gold_indices:
    :param w2v_indices:
    :return:
    """
    gold_indices = extract_indices(gold_indices)
    w2v_indices = extract_indices(w2v_indices)

    gold_indices = sorted(gold_indices)
    w2v_indices = sorted(w2v_indices)

    def check_tp_and_fp(gold_indices_list, w2v_index):
        for i, g_val in enumerate(gold_indices_list):
            if w2v_index[0] == gold_indices_list[i][0] and w2v_index[1] == gold_indices_list[i][1]:
                return {"cos": w2v_indices[key][2], "count": {"fn": 0, "fp": 0, "tp": 1}}

        return {"cos": w2v_index[2], "count": {"fn": 0, "fp": 1, "tp": 0}}

    def check_fn(w2v_indices_list, g_index):
        w2v_check = []

        # remove the "cos"-key for the check afterwards
        for i, val in enumerate(w2v_indices_list):
            w2v_check.append([val[0], val[1]])

        if g_index not in w2v_check:
            return {"cos": None, "count": {"fn": 0, "fp": 0, "tp": 0}}

        return False

    # print "compare_indices(): -----------------------------------"

    # print "gold:", gold_indices
    # print "w2v:", w2v_indices

    doc_compare = []

    for key, w2v_val in enumerate(w2v_indices):
        result = check_tp_and_fp(gold_indices, w2v_indices[key])
        doc_compare.append(result)

    for key, gold_val in enumerate(gold_indices):
        result = check_fn(w2v_indices, gold_indices[key])
        # print "result"
        # pprint(result)
        if result:
            doc_compare.append(result)

    return doc_compare


def count_values_from_data(cos, data):
    all_tp_fp_fn = []

    for i in data:
        all_tp_fp_fn.append(count_all_tp_fp_fn(cos, i))

    tp = 0
    fp = 0
    fn = 0

    for i in all_tp_fp_fn:
        tp += i["tp"]
        fp += i["fp"]
        fn += i["fn"]

    print "\nValues for cosine =", cos, ":"
    print "tp:", tp
    print "fp:", fp
    print "fn:", fn

    return {"cos": cos, "tp": tp, "fp": fp, "fn": fn}


def calc_cos_precision(cos, data):
    values = count_values_from_data(cos, data)
    precision = calc_precision(values["tp"], values["fp"])
    return [cos, precision]


def calc_cos_recall(cos, data):
    values = count_values_from_data(cos, data)
    recall = calc_recall(values["tp"], values["fn"])
    return [cos, recall]


def calc_precision_recall(cos, data):
    values = count_values_from_data(cos, data)
    precision = calc_precision(values["tp"], values["fp"])
    recall = calc_recall(values["tp"], values["fn"])
    return [recall, precision]


def calc_f1_score(cos, data):
    values = count_values_from_data(cos, data)

    recall = calc_recall(values["tp"], values["fn"])
    precision = calc_precision(values["tp"], values["fp"])

    print "recall", recall
    print "precision", precision

    f1_score = 2 * (precision * recall) / (precision + recall)
    return [cos, f1_score]


def count_all_tp_fp_fn(cos, data):
    filtered_data = []
    ignored_data = []

    # print "##################### P/R ######################"
    # print "data:"
    # pprint(data)

    for i in data:
        # print "cos:", cos
        # print "i:", i
        # print "i['cos']:", i["cos"]
        # print "data", data[0]

        if i["cos"] >= cos or i["cos"] is None:
            filtered_data.append(i)
        else:
            ignored_data.append(i)

    # print "filtered_data:"
    # pprint(filtered_data)
    #
    # print "ignored_data:"
    # pprint(ignored_data)

    tp = calc_tp(filtered_data)
    fp = calc_fp(filtered_data)
    fn = calc_fn(data, ignored_data)

    # pprint({"tp": tp, "fp": fp, "fn": fn})
    return {"tp": tp, "fp": fp, "fn": fn}


def calc_tp(doc):
    count = 0
    for i in doc:
        if i["count"]["tp"] == 1:
            count += 1
    return count


def calc_fp(doc):
    count = 0
    for i in doc:
        if i["count"]["fp"] == 1:
            count += 1
    return count


def calc_fn(doc, ignored_doc):
    count = 0

    for i in doc:
        if i["count"]["fn"] == 1:
            count += 1

    for i in ignored_doc:
        if i["count"]["tp"] == 1:
            count += 1

    return count


def calc_tn(doc):
    count = 0

    for i in doc:
        if i["count"]["tn"] == 1:
            count += 1

    return count


def extract_indices(doc=None):
    """
    Extracts all indices from a specific nested list.
    :param doc:
    :type doc: dict
    :return: A list of all extracted indices
    :rtype: list
    """
    if doc is None:
        return []
    else:
        new_list = []

        indices = doc["indices"]
        entities = doc["entities"]
        w2v = doc["cos_dist"]

        # print "entities:", entities

        for key, i in enumerate(indices):
            entity = entities[key]
            w2v_word = w2v[key][0]
            cos_dist = w2v[key][1]

            # print "entity:", entity
            print

            for j in i:
                j.append(entity)
                j.append(w2v_word)
                j.append(cos_dist)

                print j

                new_list.append(j)

        return new_list


def insert_in_string(string=str(), index=int(), insert=str()):
    """
    Inserts a string in another string at the given index position.
    :param string: The base string where the other string will be inserted.
    :param index: The index at which position the string will be inserted.
    :param insert: The string to be inserted.
    :type string: str
    :type index: int
    :type insert: str
    :return: The base string with the inserted string at the given position.
    :rtype: str
    """
    return string[:index] + insert + string[index:]


def replace_gt_and_lt(string=str()):
    """
    Workaround the bug, where ">" and "<" signs are displayed in the final html document.
    :param string: buggy html document
    :type string: str
    :return: Cleaned up html document.
    :rtype: str
    """
    return string.replace('&gt;', '>').replace('&lt;', '<')


def format_number(num):
    """
    Turns a number into a rounded decimal, if its greater that 1. If it's lower that 1 than the float is reduced to one
    digit after the point.
    :param num: a floating number
    :type num: float
    :return: A rounded decimal number for better presentation on the GUI.
    :rtype: decimal
    """
    dec = None
    try:
        dec = decimal.Decimal(num)
    except Exception as e:
        print "format_number error: " + e.message
    tup = dec.as_tuple()
    delta = len(tup.digits) + tup.exponent
    digits = ''.join(str(d) for d in tup.digits)
    if delta <= 0:
        zeros = abs(tup.exponent) - len(tup.digits)
        val = '0.' + ('0' * zeros) + digits
    else:
        val = digits[:delta] + ('0' * tup.exponent) + '.' + digits[delta:]
    val = val.rstrip('0')
    if val[-1] == '.':
        val = val[:-1]
    if tup.sign:
        return '-' + val
    return val


def open_json(path=str()):
    """
    Opens a JSON-file from the given path.
    :param path: the path to the JSON-file
    :type path: str
    :return: the json as a list
    :rtype: list
    """
    print "opened file in path: ", path

    try:
        with open(path, mode="r") as data:
            return json.load(data, encoding="utf-8")
    except IOError as e:
        print "IOError:" + e.message
        return False


def export_html(path=str()):
    """
    Dunno, makes no sense to me. Just leave it like this for now
    :param path:
    :type path: str
    :return: Nothing
    :rtype: None
    """
    lxml.html.open_in_browser(path)


def count_existing_words(gold_words, dictionary):
    """

    :param gold_words:
    :param dictionary:
    :type gold_words: dict
    :type dictionary: list
    :return:
    :rtype: list
    """

    existing_words = 0
    new_words = 0

    for key, sentence in enumerate(gold_words):
        for i in gold_words[key]["entities"]:
            if i in dictionary:
                existing_words += 1
            else:
                new_words += 1

    total = new_words + existing_words
    new_in_percent = (new_words / float(total)) * 100

    return {"exist": existing_words, "new": new_words, "new in %": round(new_in_percent, 1)}


def create_html(data=None, tags=None):
    """
    Creates a HTML document out of specific json data.
    :param data: dict with
    [
        {
            "url": "<some url>",
            "_id": {
                "$oid": "<some id>"
            },
            "extracted_text": "<some text>"
        },
        ...
    ]
    :param tags: dict with
    [
        {
            "entities": ["<some entity>", ...],
            "_id": "<some id>",
            "indices": [<some index number>, ...]
        },
        ...
    ]
    :type data: list
    :type tags: list
    :return: Formatted html document as text.
    :rtype: str
    """
    if tags is None:
        tags = []
    if data is None:
        data = []

    def tag_start(data_tooltip, data_dict_word=None, data_cosine=None):
        if data_dict_word is None:
            data_dict_word = "null"
        if data_cosine is None:
            data_cosine = "null"

        if data_cosine == "null":
            span_tag = '<span class="found null tooltipped" data-tooltip="' + data_tooltip + \
                       '" data-position="top" data-delay="50" data-dict-word="' + data_dict_word + \
                       '" data-cosine="' + data_cosine + '">'
        else:
            span_tag = '<span class="found tooltipped" data-tooltip="' + data_tooltip + \
                       '" data-position="top" data-delay="50" data-dict-word="' + data_dict_word + \
                       '" data-cosine="' + data_cosine + '">'

        return span_tag

    tag_end = '</span>'

    sections = []  # contains all the tagged documents

    for docs in data:
        doc_id = uni2utf(docs["_id"]["$oid"])
        text = docs["extracted_text"]

        for tag in tags:
            if tag["_id"] == doc_id:
                extracted_indices = extract_indices(tag)
                # print
                # pprint(extracted_indices)
                # print
                indices = sort_2d_array(extracted_indices)
                # pprint(indices)
                # print

                # remove all intersecting indices
                restart = True
                while restart:
                    for i, val in enumerate(indices):
                        if i < len(indices) - 1:
                            value = merge_intersected_indices(indices[i], indices[i + 1])
                            if value:
                                indices[i] = value
                                del indices[i + 1]
                                break
                        else:
                            restart = False

                added = 0  # the current string position, where the html tag will be added

                for key, index in enumerate(indices):
                    j = index[0] + added

                    similar_word = None
                    cosine_distance = None

                    if len(index) > 3:
                        similar_word = uni2utf(str(index[3]))
                        cosine_distance = uni2utf(str(index[4]))
                        tooltip_text = "similar word: " + similar_word + "<br/>cosine: " + cosine_distance
                    else:
                        print "#########################################################################"
                        print "ERROR: wrong index list"
                        pprint(index)
                        tooltip_text = "similar word: unknown<br/>cosine: null"
                    exists_tag_start_string = tag_start(data_tooltip=tooltip_text, data_dict_word=similar_word,
                                                        data_cosine=cosine_distance)
                    text = insert_in_string(text, j, exists_tag_start_string)
                    added += len(exists_tag_start_string)
                    j = index[1] + added
                    text = insert_in_string(text, j, tag_end)
                    added += len(tag_end)
                    # print added

        section = E.DIV(E.P("Document ID: " + doc_id), E.E.section(text, id=doc_id))
        card = E.DIV(E.CLASS("col s12 m12 l6"), E.DIV(E.CLASS("card-panel"), section))

        sections.append(card)

    stylesheets = [E.LINK(rel="stylesheet", href="css/materialize.min.css"),
                   E.LINK(rel="stylesheet", href="css/main.css")]

    scripts = [E.SCRIPT(src="js/jquery-2.2.0.min.js"),
               E.SCRIPT(src="js/materialize.js"),
               E.SCRIPT(src="js/dictionary.js"),
               E.SCRIPT(src="js/main.js")]

    header = E.DIV(E.CLASS("header col s12 orange darken-3"), E.H1("Zalando Textmining"))
    legend = E.DIV(E.CLASS("legend col s12 white"),
                   E.H3("Legend"),
                   E.UL(
                        E.LI(E.SPAN(E.CLASS("exists-in-dict"), "Word exists in dictionary")),
                        E.LI(E.SPAN(E.CLASS("new-for-dict"), "New word for dictionary")),
                        E.LI(E.SPAN(E.CLASS("null"), "Null"))
                   ))

    doc_container = [E.DIV(E.CLASS("row"), header, legend, *sections)]

    head = E.HEAD(*stylesheets)
    body = E.BODY(*(doc_container + scripts))

    html = E.HTML(head, body)

    # pretty string
    # print "<!Doctype html>\n" + lxml.html.tostring(html, pretty_print=True)
    head = "<!Doctype html>\n"

    html = head + lxml.html.tostring(html, pretty_print=True)

    return replace_gt_and_lt(html)
    # return replace_gt_and_lt("<!Doctype html>\n" + lxml.html.tostring(html, pretty_print=True))


def calc_precision(tp, fp):
    """
    Calculates the precision of a word2vec implementation.
    :param tp: true positives
    :param fp: false positives
    :type tp: int
    :type fp: int
    :return: The precision value for the given parameters.
    :rtype: float
    """
    precision = 0
    if (tp == 0) and (fp == 0):
        return precision
    else:
        precision = float(tp) / (tp + fp)
    return precision


def calc_recall(tp, fn):
    """
    Calculates the recall of a word2vec implementation.
    :param tp: true positives
    :param fn: false negatives
    :type tp: int
    :type fn: int
    :return: The recall value for the given parameters.
    :rtype: float
    """
    recall = float(tp) / (tp + fn)
    return recall


def step_range(start, stop, step):
    """
    A range function where you can set a step by which the iterator is raised.
    :param start: the start value
    :param stop: the stop value
    :param step: the number by which the iteration is increased
    :type start: int
    :type stop: int
    :type step: float
    :return: range value for loops
    :rtype: list[int]
    """
    r = start
    while round(r, 2) <= stop:
        yield round(r, 2)
        r += step
