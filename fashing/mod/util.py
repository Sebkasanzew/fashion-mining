#!/usr/bin/env python
# -*- coding: utf-8 -*-

import decimal
import json
from pprint import pprint
import lxml  # xml functions
from lxml.html import builder as E  # for building a html document


def uni2utf(string=str()):
    """
    Converts an unicode string into an utf-8 string.
    :param string: the unicode string
    :type string: str
    :return: An UTF-8 string
    :rtype: str
    """
    return unicode(string).encode('utf8')


def sort_2d_array(array=None):
    """
    Sort a 2D array after the first number ascending.
    :param array: unsorted 2D-list
    :type array: list
    :return: sorted 2D-list
    :rtype: list[list[int]]
    """
    if array is None:
        array = []
    return sorted(array, key=lambda l: l[0], reverse=False)


def sort_3d_array(array=None):
    """
    Sort a 3D array after the first number ascending.
    :param array: unsorted 3D-list
    :type array: list
    :return: sorted 3D-list
    :rtype: list[list[list[int]]]
    """
    if array is None:
        array = []
    return sorted(array, key=lambda l: l[0], reverse=False)


def merge_intersected_indicies(array_one=None, array_two=None):
    """
    Merges two list elements into one list if they ave an intersection.
    :param array_one: first list element
    :param array_two: second list element
    :type array_one: list[int]
    :type array_two: list[int]
    :return: returns the intersected list.
    :rtype: list[int]
    """
    if array_one is None:
        array_one = []

    if array_two is None:
        array_two = []

    if array_one[1] >= array_two[0]:
        return [array_one[0], array_two[1]]
    elif (array_two[1] >= array_one[0]) and (array_two[0] < array_one[0]):  # if the given parameters are switched
        return [array_two[0], array_one[1]]
    else:
        return False


def compare_docs(gold_document=None, w2v_document=None):
    """
    Compares two documents and returns the precision-recall data for a graph.
    :param gold_document: the document with the gold standard
    :param w2v_document: the document generated by word2vec
    :type gold_document: list
    :type w2v_document: list
    :return: A 2D-list with the graph data. The values should be between 0 and 1.
    :rtype: list[list[int]]
    """
    compared = []

    if gold_document is None:
        gold_document = [{"entities": ["a", "b"], "_id": "b1", "indicies": [[[1, 2], [4, 6]], [[8, 10]]]}]

    if w2v_document is None:
        w2v_document = [{"entities": ["a", "b", "c", "d"], "_id": "b1", "cosDist": [.7, .9, .2, .4],
                         "indicies": [[[14, 18]], [[1, 2], [4, 6]], [[8, 10]], [[11, 13], [14, 16]]]}]

    for doc2 in w2v_document:
        print doc2
        for i, val in enumerate(doc2):
            # print doc2["cosDist"], i
            cos = doc2["cosDist"][i]
            for j in doc2["indicies"][i]:
                j.append(cos)

    for doc1 in gold_document:
        for doc2 in w2v_document:
            if doc1["_id"] == doc2["_id"]:
                compared.append(compare_indices(doc1["indicies"], doc2["indicies"]))
                print "compared", compared

    for i in step_range(0, 1, 0.05):
        calc_precision_recall(i, compared)

    # TODO: replace this static return with the calculated one
    return [
        [0, 1],
        [.05, .05],
        [.1, .1],
        [.15, .15],
        [.2, .2],
        [.25, .25],
        [.3, .3],
        [.35, .35],
        [.4, .4],
        [.45, .45],
        [.5, .5],
        [.55, .55],
        [.6, .6],
        [.65, .65],
        [.7, .7],
        [.75, .75],
        [.8, .8],
        [.85, .85],
        [.9, .9],
        [.95, .95],
        [1, 0],
    ]


def compare_indices(gold_indices, w2v_indices):
    # TODO: compare the indices in the correct way
    """
    :param gold_indices:
    :param w2v_indices:
    :return:
    """
    gold_indices = extract_indices(gold_indices)
    w2v_indices = extract_indices(w2v_indices)

    gold_indices = sorted(gold_indices)
    w2v_indices = sorted(w2v_indices)

    print "gold:", gold_indices
    print "w2v:", w2v_indices

    doc_compare = []

    def check_fp(gold_index, w2v_index):
        """
        Checks if the word from word2vec is a false positive by checking if the same index is not present in the gold
        standard index.
        :param gold_index: the gold index
        :param w2v_index: the word2vec index
        :type gold_index: int
        :type w2v_index: int
        :return: Return True if it's a false positive.
        :rtype: bool
        """
        return w2v_index not in gold_index

    def check_tp(gold_index, w2v_index):
        """
        Checks if the word from word2vec is a true positive by checking if the same index is present in the gold
        standard index.
        :param gold_index: the gold index
        :param w2v_index: the word2vec index
        :type gold_index: int
        :type w2v_index: int
        :return: Return True if it's a true positive.
        :rtype: bool
        """
        return w2v_index in gold_index

    def check_fn(gold_index, w2v_index):
        """
        Checks if the word from gold standard is a false negative by checking if the same index is not present in the
        word2vec index.
        :param gold_index: the gold index
        :param w2v_index: the word2vec index
        :type gold_index: int
        :type w2v_index: int
        :return: Return True if it's a false negative.
        :rtype: bool
        """
        return gold_index not in w2v_index

    for i, val in enumerate(gold_indices):
        print "gold index:", i
        for j, val2 in enumerate(w2v_indices):
            print "w2v index:", j
            # print w2v_indices
            result = {}
            if check_fn(gold_indices[i], w2v_indices[j]):
                result = {"cos": w2v_indices[j][2], "count": {"fn": 1, "fp": 0, "tp": 0}}

            if check_fp(gold_indices[i], w2v_indices[j]):
                result = {"cos": w2v_indices[j][2], "count": {"fn": 0, "fp": 1, "tp": 0}}

            if check_tp(gold_indices[i], w2v_indices[j]):
                result = {"cos": w2v_indices[j][2], "count": {"fn": 0, "fp": 0, "tp": 1}}

            doc_compare.append(result)

    return doc_compare


def calc_precision_recall(cos, data):
    # TODO: calculate precision/recall
    """
    
    :param cos:
    :param data:
    :type cos:
    :type data:
    :return:
    :rtype:
    """
    filtered = []

    for i, val in enumerate(data):
        print "############### DATA", data
        if float(data[0][0][i][2]) > cos:
            count = data[0][0]["count"]
            r = calc_recall(count["tp"], count["fn"])
            p = calc_precision(count["tp"], count["fp"])
            filtered.append([r, p])


def extract_indices(array=None):
    """
    Extracts all indices from a specific nested list.
    :param array:
    :type array: list[list[int]]
    :return: A list of all extracted indices
    :rtype: list
    """
    if array is None:
        return []

    new_list = []

    for i in array:
        for j in i:
            new_list.append(j)

    return new_list


def insert_in_string(string=str(), index=int(), insert=str()):
    """
    Inserts a string in another string at the given index position.
    :param string: The base string where the other string will be inserted.
    :param index: The index at which position the string will be inserted.
    :param insert: The string to be inserted.
    :type string: str
    :type index: int
    :type insert: str
    :return: The base string with the inserted string at the given position.
    :rtype: str
    """
    return string[:index] + insert + string[index:]


def replace_gt_and_lt(string=str()):
    """
    Workaround the bug, where ">" and "<" signs are displayed in the final html document.
    :param string: buggy html document
    :type string: str
    :return: Cleaned up html document.
    :rtype: str
    """
    return string.replace('&gt;', '>').replace('&lt;', '<')


def format_number(num):
    """
    Turns a number into a rounded decimal, if its greater that 1. If it's lower that 1 than the float is reduced to one
    digit after the point.
    :param num: a floating number
    :type num: float
    :return: A rounded decimal number for better presentation on the GUI.
    :rtype: decimal
    """
    dec = None
    try:
        dec = decimal.Decimal(num)
    except Exception as e:
        print "format_number error: " + e.message
    tup = dec.as_tuple()
    delta = len(tup.digits) + tup.exponent
    digits = ''.join(str(d) for d in tup.digits)
    if delta <= 0:
        zeros = abs(tup.exponent) - len(tup.digits)
        val = '0.' + ('0' * zeros) + digits
    else:
        val = digits[:delta] + ('0' * tup.exponent) + '.' + digits[delta:]
    val = val.rstrip('0')
    if val[-1] == '.':
        val = val[:-1]
    if tup.sign:
        return '-' + val
    return val


def open_json(path=str()):
    """
    Opens a JSON-file from the given path.
    :param path: the path to the JSON-file
    :type path: str
    :return: the json as a list
    :rtype: list
    """
    print "opened file in path: ", path
    with open(path, mode="r") as data:
        return json.load(data, encoding="utf-8")


def export_html(path=str()):
    """
    Dunno, makes no sense to me. Just leave it like this for now
    :param path:
    :type path: str
    :return: Nothing
    :rtype: None
    """
    lxml.html.open_in_browser(path)


def create_html(data=None, tags=None):
    """
    Creates a HTML document out of specific json data.
    :param data: dict with
    [
        {
            "url": "<some url>",
            "_id": {
                "$oid": "<some id>"
            },
            "extracted_text": "<some text>"
        },
        ...
    ]
    :param tags: dict with
    [
        {
            "entities": ["<some entity>", ...],
            "_id": "<some id>",
            "indices": [<some index number>, ...]
        },
        ...
    ]
    :type data: dict
    :type tags: dict
    :return: Formatted html document as text.
    :rtype: str
    """
    if tags is None:
        tags = {}
    if data is None:
        data = {}

    brand_tag_start = '<span class="brand" style="color: red">'
    brand_tag_end = '</span>'

    sections = []

    for docs in data:
        doc_id = uni2utf(docs["_id"]["$oid"])
        text = docs["extracted_text"]

        for tag in tags:
            if tag["_id"] == doc_id:
                indicies = sort_2d_array(extract_indices(tag["indicies"]))

                # remove all intersecting indicies
                restart = True
                while restart:
                    for i, val in enumerate(indicies):
                        if i < len(indicies) - 1:
                            value = merge_intersected_indicies(indicies[i], indicies[i + 1])
                            if value:
                                indicies[i] = value
                                del indicies[i + 1]
                                break
                        else:
                            restart = False

                added = 0
                for index in indicies:
                    j = index[0] + added
                    text = insert_in_string(text, j, brand_tag_start)
                    added += len(brand_tag_start)
                    j = index[1] + added
                    text = insert_in_string(text, j, brand_tag_end)
                    added += len(brand_tag_end)
                    print added

        sections.append(E.E.section(text, id=doc_id, style="margin: 10px"))

    head = E.HEAD()
    body = E.BODY(*sections)

    # print sections

    html = E.HTML(head, body)

    # pretty string
    # print "<!Doctype html>\n" + lxml.html.tostring(html, pretty_print=True)
    return replace_gt_and_lt("<!Doctype html>\n" + lxml.html.tostring(html, pretty_print=True))


def calc_precision(tp, fp):
    """
    Calculates the precision of a word2vec implementation.
    :param tp: true positives
    :param fp: false positives
    :type tp: int
    :type fp: int
    :return: The precision value for the given parameters.
    :rtype: float
    """
    precision = tp / (tp + fp)
    return precision


def calc_recall(tp, fn):
    """
    Calculates the recall of a word2vec implementation.
    :param tp: true positives
    :param fn: false negatives
    :type tp: int
    :type fn: int
    :return: The recall value for the given parameters.
    :rtype: float
    """
    recall = tp / (tp + fn)
    return recall


def step_range(start, stop, step):
    """
    A range function where you can set a step by which the iterator is raised.
    :param start: the start value
    :param stop: the stop value
    :param step: the number by which the iteration is increased
    :type start: int
    :type stop: int
    :type step: float
    :return: range value for loops
    :rtype: list[int]
    """
    r = start
    while r < stop:
        yield r
        r += step
